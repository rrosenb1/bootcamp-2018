# -----------------------------------------------------------------------------|
# Advanced data manipulation - data.table ----
# -----------------------------------------------------------------------------|

# FIRST: set the right working directory (.../bootcamp-2018)

# -----------------------------------------------------------------------------|
# data.table basics ----
# -----------------------------------------------------------------------------|

# read in data ----

# import data.table library
library(data.table)
library(lubridate)

data_file <- here::here("data", "generation.csv")

# read in two versions of data, one as a data.frame and one as a data.table. these appear very similar
generation_df <- read.csv(data_file, stringsAsFactors = F)
generation_dt <- fread(data_file)

# compare
View(generation_df)
View(generation_dt)

generation_df
generation_dt

class(generation_df) # "data.frame"
class(generation_dt) # "data.table" "data.frame"

str(generation_df)
str(generation_dt)

# -----------------------------------------------------------------------------|
# slicing, column operations, and group by ----
# -----------------------------------------------------------------------------|

# syntax

# data.frame column selection
generation_df[,"small_hydro"]
select(generation_df, small_hydro)

# data.table column selection
generation_dt[,small_hydro] # No quotes on column names!

# data.frame column selection (multiple)
select(generation_df, datetime, small_hydro)

# data.table column selection (multiple)
generation_dt[,.(datetime, small_hydro)] #.() function is the same thing as a list.
generation_dt[,.(small_hydro)]


# add row filter in i
generation_dt[solar == 0,.(datetime, small_hydro)] # give small hydro values when solar == 0
generation_dt[solar == 0 && wind > 0 ,.(datetime, small_hydro)]

# try column operations
generation_dt[,.(small_hydro + large_hydro)] # the .() operator makes the output a list
generation_dt[,.(more_hydro = small_hydro + large_hydro)] # naming the list will name the variable in the output


generation_dt[,.(datetime,
                 small_hydro,
                 large_hydro,
                 all_hydro = small_hydro + large_hydro)]


# try in-place column operations
generation_dt[,all_hydro := small_hydro + large_hydro]
generation_dt["all_hydro"] <- generation_dt["small_hydro"] + generation_dt["large_hydro"] # this is what we would have to do in base R to get the same effect



# add in by
# how much energy is generated by hydro plants when the output of
# solar plants is zero?

# one way to generate this
generation_dt[solar > 0, solar_on := TRUE]  # row filter (which row values do you want? Only where solar > 0). For these, assign solar_on = T by creating the column solar_on (or editing it if it already exists)
generation_dt[is.na(solar_on), solar_on := FALSE]

# sum by solar_on column
generation_dt[,sum(all_hydro), by = solar_on] # sum of all hydro by group (solar_on is T and solar_on is F)

# technically, can do this all in one line
generation_dt[,sum(all_hydro), by = solar > 0] # wrap it in a list and add a name to make these columns have names

# can add as many by groupings as we want
generation_dt[,sum(all_hydro), by = .(solar > 0, wind > 0)]

# Exercise 1
#
# Using `data.table`'s special operator and what you learned about converting
# datetimes in the previous session, convert the `datetime` column to a POSIX
# object. Then, create a new `data.table` that contains the total renewable
# energy generation (solar + wind) by hour and day.
# Hint: you will probably need lubridate's functions `day()` and `hour()`

# run answer

# convert datetime to POSIXlt
generation_dt[,datetime := as_datetime(datetime)]
class(generation_dt$datetime)

# create column for solar + wind values (this is a column operation), group by day and hour
generation_dt[, .(solar_wind = solar + wind), by = .(day(datetime), hour(datetime)) ]
head(generation_dt)

# -----------------------------------------------------------------------------|
# `data.table` upgrades to other functions ----
# -----------------------------------------------------------------------------|

# from this morning
# imports <- fread(here::here("data", "imports.csv"))
# imports[,datetime := as_datetime(datetime)]

# all_generation <- merge(generation_dt, imports, by = "datetime")

# all_generation_long <-  melt(all_generation,
#                              id.vars = "datetime", 
#                              variable.name = "type")

# now most calculations are much easier
# hourly_generation <- all_generation_long[,.(generation = mean(value)), 
#                                          by = .(hour(datetime), type)]

# check to see if this makes sense
# hourly_generation[type == "solar"]

# -----------------------------------------------------------------------------|
# other features ----
# -----------------------------------------------------------------------------|

# keys

# check the current key
# key(generation_dt)

# set key
# setkey(generation_dt, datetime)
# key(generation_dt)

# joins

# this only works if at least one key is set
# generation_dt[imports]

# this can also be used to select rows
# fewer_imports <- imports[day(datetime) == 3 | day(datetime) == 4]
# generation_dt[fewer_imports]

# operations can be performed in the same step as the merge
# generation_dt[fewer_imports, sum(small_hydro + large_hydro), by = day(datetime)]


